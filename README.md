<h2>  Модуль 11. Java коллекции. Практика  </h2>
<h3> Вопросы:  </h3> 
<h5> 1. Что такое коллекции в java и для чего они используются? </h5>
<br>
<strong> Коллекции </strong> —  это динамические типы для хранения однотипных групп объектов, предназначенные для удобного хранения, управления и манипулирования данными. Коллекции в Java предоставляют удобные методы для добавления, удаления, поиска и обработки элементов, а также поддерживают различные алгоритмы и операции для работы с данными.<br>
<ol> 
Например коллекции используются в Java:
<li> списки <i> 'List'</i> - могут содержать упорядоченные последовательности элементов. <br></li>
<li> множества <i> 'Set' </i> - уникальные элементы без повторений. <br></li>
<li> карта <i> 'Map' </i> предоставляет механизм для хранения пар "ключ-значение".<br></li>
</ol>

<h5> 2. Назовите 3 основных интерфейса, которые наследуются от интерфейса Collection в java? </h5>
<ol> 
<li> <strong> Set :</strong> Интерфейс Set представляет собой коллекцию уникальных элементов, то есть каждый элемент может встречаться не более одного раза. Основные реализации включают <strong> HashSet </strong>, <strong> LinkedHashSet </strong> и  <strong> TreeSet </strong>. <br></li>
<li> <strong> List: </strong> Интерфейс List представляет собой упорядоченную коллекцию объектов, в которой каждый элемент имеет свой индекс. Дубликаты допускаются. Основные реализации включают <strong> ArrayList</strong>,  <strong> LinkedList</strong> и <strong> Vector </strong>.<br></li>
<li> <strong> Queue: </strong> Интерфейс Queue представляет собой коллекцию элементов, в которой элементы добавляются в конец и удаляются из начала. Основные реализации включают <strong> LinkedList  (как двунаправленную очередь) </strong> и <strong> PriorityQueue </strong>. <br></li>
</ol>

<h5> 3. Назовите отличия реализаций ArrayList от LinkedList.</h5>
<ol>
<h6> Структура данных: </h6>
<strong> ArrayList: </strong> Реализован на основе динамического массива. При достижении предельного размера массива он увеличивается путем создания нового массива большего размера и копирования элементов. <br>
<strong> LinkedList: </strong> Реализован на основе двусвязного списка, где каждый элемент (Node) содержит ссылки на предыдущий и следующий элементы. <br> 

<h6> Когда использовать:<br></h6>
<strong> ArrayList: </strong> Лучше подходит, если часто требуется доступ по индексу или требуется компактное использование памяти. Хорошо подходит для сценариев, когда операции вставки и удаления выполняются редко или в конце списка.
<strong> LinkedList: </strong> Предпочтителен, если часто требуется вставка и удаление элементов в середине списка или если важнее производительность операций вставки и удаления, чем доступ по индексу. <br>
</ol>

![Отличие ArrayList от LinkedList ](https://github.com/Pexini/Module11HomeTask/blob/main/differentsArrayandList.png)

<h5> 4. Что такое множества? Какие есть реализации интерфейса Set в java?</h5>
<ol> 
Множества в Java представляют собой коллекции, которые содержат только уникальные элементы, то есть каждый элемент может встречаться в множестве не более одного раза. Это отличает их от списков, которые могут содержать дублирующиеся элементы.
<br>
<li> HashSet - основанная на хеш-таблице. Она обеспечивает почти постоянное время выполнения для операций добавления, удаления и проверки наличия элемента. <br> </li>
<li> Treeset - основанная на красно-черном дереве. Элементы в TreeSet хранятся в отсортированном порядке. Эта реализация обеспечивает гарантированное время выполнения для основных операций (вставка, удаление, поиск) в O(log n).  <br> </li>
<li> LinkedHashSet - объединяет функциональность HashSet и связанного списка. Она поддерживает порядок вставки элементов, а также обеспечивает почти постоянное время выполнения для операций добавления, удаления и проверки наличия элемента, подобно HashSet. <br> </li>
<i> HashSet обычно является предпочтительным выбором, если важна быстрая проверка наличия элемента, в то время как TreeSet может быть полезен, если требуется сохранение элементов в отсортированном порядке. </i>
</ol>

<h5> 5. Какая связь между методами equals() и hashCode()? Что такое коллизия?</h5>
<ol> 
Методы equals() и hashCode() в Java связаны с механизмом работы с хеш-таблицами и использованием объектов в качестве ключей в коллекциях, таких как HashMap, HashSet. <br>
<li> Метод equals(): Этот метод используется для сравнения двух объектов на равенство. По умолчанию, метод equals() в классе Object сравнивает ссылки на объекты, проверяя, указывают ли они на один и тот же объект в памяти. Однако, в большинстве случаев необходимо переопределить метод equals() в пользовательских классах, чтобы он сравнивал содержимое объектов, а не только ссылки. <br> </li>
<li> Метод hashCode(): Этот метод возвращает целочисленное значение (хеш-код) объекта. Хеш-код используется в хеш-таблицах для определения индекса, по которому объект будет храниться в таблице. Хорошо реализованный метод hashCode() должен возвращать разные значения для разных объектов, но для равных объектов он должен возвращать одинаковые значения. </li>
<i> Связь между этими двумя методами заключается в том, что если два объекта равны согласно методу equals(), то их хеш-коды, возвращаемые методом hashCode(), также должны быть равны. И наоборот, если два объекта имеют одинаковые хеш-коды, это еще не означает, что они равны согласно методу equals(). 

Коллизия возникает, когда два разных объекта имеют одинаковые хеш-коды. Такие ситуации неизбежны из-за ограниченного диапазона хеш-кодов и бесконечного числа возможных объектов. Хорошая реализация хеш-функции (и, следовательно, метода hashCode()) старается минимизировать вероятность коллизий, но полностью исключить их невозможно. В случае коллизии объекты будут храниться в одной и той же "корзине" (bucket) хеш-таблицы, что может снизить производительность операций добавления и поиска в коллекции. </i>
</ol>

<h5> 6. Истинно ли утверждение, что если у двух объектов хеш-код равен, значит и объекты равны? </h5>
<ol> 
<strong > Нет, это утверждение не является истинным. Если у двух объектов одинаковый хеш-код, это не обязательно означает, что эти объекты равны. <br> </strong>
Пример: <br>
<li> Хеш-код (возвращаемый методом hashCode()) — это целочисленное значение, которое вычисляется на основе некоторых свойств объекта. Два разных объекта могут иметь одинаковый хеш-код. Это называется коллизией. Коллизии неизбежны, потому что количество возможных объектов намного больше, чем количество возможных значений хеш-кодов (целые числа). <br> </li>
<li> Метод equals() определяет, равны ли два объекта. Два объекта могут иметь одинаковый хеш-код, но быть неравными согласно методу equals(). <br> </li>
</ol>

<h5> 7. Что такое ассоциативный массив в java? Какие реализации интерфейса Map вы знаете? </h5>
<ol> 
<strong > Ассоциативный массив в Java, также известный как хэш-таблица или словарь, представляет собой структуру данных, которая хранит пары "ключ-значение". Интерфейс, который представляет ассоциативный массив в Java, называется Map. Он позволяет быстро находить значение по ключу. <br> </strong>
<br>
<li> <mark> HashMap: </mark> 
<ul> <li> Наиболее часто используемая реализация Map, основанная на хэш-таблице.</li> 
<li> Позволяет хранить null для ключей и значений, не поддерживает упорядоченность элементов.</li> 
<li> Применяется когда требуется быстрое выполнение операций добавления, удаления и поиска.</li> </ul> </li>
<br>
<li> <mark> LinkedHashMap: </mark>   <br> 
<ul> <li> Расширяет HashMap и поддерживает порядок вставки.</li> 
<li> Сохраняет порядок, в котором элементы были добавлены, либо порядок доступа (если установлен режим LRU - Least Recently Used).</li> 
<li> Применяется когда важно сохранять порядок вставки элементов.</li> </ul> </li>
<br>
<li> <mark> TreeMap: </mark>   <br> 
<ul> <li> Реализует интерфейс NavigableMap, основан на красно-черном дереве.</li> 
<li>  Поддерживает упорядоченность элементов по их естественному порядку или по заданному компаратору.</li> 
<li> Применяется когда требуется отсортированный Map.</li> </ul> </li>
<br>
<li> <mark> Hashtable: </mark>   <br> 
<ul> <li> Старая реализация ассоциативного массива, синхронизированная (потокобезопасная).</li> 
<li>  Не позволяет хранить null для ключей и значений, синхронизирована.</li> 
<li> Применяется в многопоточных приложениях, когда требуется потокобезопасность (однако обычно предпочтительнее использовать ConcurrentHashMap).</li> </ul> </li>
<br>
<li> <mark> ConcurrentHashMap: </mark>   <br> 
<ul> <li> Реализация ассоциативного массива для многопоточных приложений.</li> 
<li>  Разделяет элементы на сегменты для повышения параллелизма, поддерживает высокую производительность при множестве параллельных операций.</li> 
<li> Применяется вмногопоточных приложениях, где требуется высокая производительность и потокобезопасность.</li> </ul> </li>
</ol>

<h5> 6. Допишите реализацию метода equals() вместо знаков / / для класса Human из 4 урока: </h5>
<ol> 
В нашем примере есть два одинаковых объекта, поля fio и birthday. <br>


    public class Human {
    private String birthday;
    private String fio;

    public Human(String birthday, String fio) {
        this.birthday = birthday;
        this.fio = fio;
    }

 <strong> Реализация метода equals() </strong> 

    @Override
    public boolean equals(Object obj) {
        if (obj == null || getClass() != obj.getClass()) return false;
        Human humanObj = (Human) obj;
        boolean result = fio.equals(humanObj.fio)
                && birthday.equals(humanObj.birthday);
        return result;
    }






</ol>

